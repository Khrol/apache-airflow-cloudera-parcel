.TH asn1rt 3 "asn1 1.6.18" "Ericsson AB" "Erlang Module Definition"
.SH NAME
asn1rt \- ASN.1 runtime support functions
.SH DESCRIPTION
.LP
This module is the interface module for the ASN\&.1 runtime support functions\&. To encode and decode ASN\&.1 types in runtime the functions in this module should be used\&.
.SH EXPORTS
.LP
.B
start() -> ok |{error,Reason}
.br
.RS
.TP 3
Types:

Reason = term()
.br
.RE
.RS
.LP
Starts the asn1 server that loads the drivers\&.
.LP
The server schedules a driver that is not blocked by another caller\&. The driver is used by the asn1 application if specs are compiled with options \fI[per_bin, optimize]\fR\& or \fI[ber_bin, optimize, driver]\fR\&\&. The server will be started automatically at encode/decode if it isn\&'t done explicitly\&. If encode/decode with driver is used in test or industrial code it is a performance gain to start it explicitly to avoid the one time load in run-time\&.
.RE
.LP
.B
stop() -> ok |{error,Reason}
.br
.RS
.TP 3
Types:

Reason = term()
.br
.RE
.RS
.LP
Stops the asn1 server and unloads the drivers\&.
.RE
.LP
.B
decode(Module,Type,Bytes) -> {ok,Value}|{error,Reason}
.br
.RS
.TP 3
Types:

Module = Type = atom()
.br
Value = Reason = term()
.br
Bytes = binary | [Int] when integer(Int), Int >= 0, Int =< 255 | binary
.br
.RE
.RS
.LP
Decodes \fIType\fR\& from \fIModule\fR\& from the list of bytes or binary \fIBytes\fR\&\&. If the module is compiled with \fIber_bin\fR\& or \fIper_bin\fR\& option \fIBytes\fR\& must be a binary\&. Returns \fI{ok,Value}\fR\& if successful\&.
.RE
.LP
.B
encode(Module,Type,Value)-> {ok,BinOrList} | {error,Reason}
.br
.RS
.TP 3
Types:

Module = Type = atom()
.br
Value = term()
.br
BinOrList = Bytes | binary()
.br
Bytes = [Int|binary|Bytes] when integer(Int), Int >= 0, Int =< 255
.br
Reason = term()
.br
.RE
.RS
.LP
Encodes \fIValue\fR\& of \fIType\fR\& defined in the ASN\&.1 module \fIModule\fR\&\&. Returns a possibly nested list of bytes and or binaries if successful\&. If \fIModule\fR\& was compiled with the options \fIper_bin\fR\& and \fIoptimize\fR\& the result is a binary\&. To get as fast execution as possible the encode function only performs rudimentary tests that the input \fIValue\fR\& is a correct instance of \fIType\fR\&\&. The length of strings is for example not always checked\&.
.RE
.LP
.B
info(Module) -> {ok,Info} | {error,Reason}
.br
.RS
.TP 3
Types:

Module = atom()
.br
Info = list()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIinfo/1\fR\& returns the version of the asn1 compiler that was used to compile the module\&. It also returns the compiler options that was used\&.
.RE
.LP
.B
load_driver() -> ok | {error,Reason}
.br
.RS
.TP 3
Types:

Reason = term()
.br
.RE
.RS
.LP
This function loads the linked-in driver before the first call to encode\&. If this function is not called the driver will be loaded automatically at the first call to encode\&. If one doesn\&'t want the performance cost of a driver load when the application is running, this function makes it possible to load the driver in an initialization\&.
.LP
The driver is only used when encoding/decoding ASN\&.1 files that were compiled with the options \fIper_bin\fR\& and \fIoptimize\fR\&\&.
.RE
.LP
.B
unload_driver() -> ok | {error,Reason}
.br
.RS
.TP 3
Types:

Reason = term()
.br
.RE
.RS
.LP
This function unloads the linked-in driver\&. When the driver has been loaded it remains in the environment until it is unloaded\&. Normally the driver should remain loaded, it is crucial for the performance of ASN\&.1 encoding\&.
.LP
The driver is only used when ASN\&.1 modules have been compiled with the flags \fIper_bin\fR\& and \fIoptimize\fR\&\&.
.RE
.LP
.B
utf8_binary_to_list(UTF8Binary) -> {ok,UnicodeList} | {error,Reason}
.br
.RS
.TP 3
Types:

UTF8Binary = binary()
.br
UnicodeList = [integer()]
.br
Reason = term()
.br
.RE
.RS
.LP
\fIutf8_binary_to_list/1\fR\& Transforms a UTF8 encoded binary to a list of integers, where each integer represents one character as its unicode value\&. The function fails if the binary is not a properly encoded UTF8 string\&.
.RE
.LP
.B
utf8_list_to_binary(UnicodeList) -> {ok,UTF8Binary} | {error,Reason}
.br
.RS
.TP 3
Types:

UnicodeList = [integer()]
.br
UTF8Binary = binary()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIutf8_list_to_binary/1\fR\& Transforms a list of integers, where each integer represents one character as its unicode value, to a UTF8 encoded binary\&.
.RE
.LP
.B
validate(Module,Type,Value) -> ok | {error,Reason}
.br
.RS
.TP 3
Types:

Module = Type = atom()
.br
Value = term()
.br
.RE
.RS
.LP
Validates that \fIValue\fR\& conforms to \fIType\fR\& from \fIModule\fR\&\&. \fINot implemented in this version of the ASN\&.1 application\&.\fR\&
.RE