.TH wx 3 "wxErlang 0.99" "" "Erlang Module Definition"
.SH NAME
wx \- A port of wxWidgets.
.SH DESCRIPTION
.LP
A port of wxWidgets\&.
.LP
This is the base api of wxWidgets\&. This module contains functions for starting and stopping the wx-server, as well as other utility functions\&.
.LP
wxWidgets is object oriented, and not functional\&. Thus, in wxErlang a module represents a class, and the object created by this class has an own type, wxCLASS()\&. This module represents the base class, and all other wxMODULE\&'s are sub-classes of this class\&.
.LP
Objects of a class are created with wxCLASS:new(\&.\&.\&.) and destroyed with wxCLASS:destroy()\&. Member functions are called with wxCLASS:member(Object, \&.\&.\&.) instead of as in C++ Object\&.member(\&.\&.\&.)\&.
.LP
Sub class modules inherit (non static) functions from their parents\&. The inherited functions are not documented in the sub-classes\&.
.LP
This erlang port of wxWidgets tries to be a one-to-one mapping with the original wxWidgets library\&. Some things are different though, as the optional arguments use property lists and can be in any order\&. The main difference is the event handling which is different from the original library\&. See \fBwxEvtHandler\fR\&\&.
.LP
The following classes are implemented directly as erlang types: 
.br
wxPoint={x,y},wxSize={w,h},wxRect={x,y,w,h},wxColour={r,g,b [,a]}, wxString=\fBunicode:charlist()\fR\&, wxGBPosition={r,c},wxGBSpan={rs,cs},wxGridCellCoords={r,c}\&.
.LP
wxWidgets uses a process specific environment, which is created by \fBwx:new/0\fR\&\&. To be able to use the environment from other processes, call \fBget_env/0\fR\& to retrieve the environment and \fBset_env/1\fR\& to assign the environment in the other process\&.
.LP
Global (classless) functions are located in the wx_misc module\&.
.SH "DATA TYPES"

.RS 2
.TP 2
.B
\fIcolour()\fR\&:

.RS 2
.LP
A 3 or 4 tuple: {R,G,B,A} or as argument {R,G,B} is also accepted where each colour channel is a an integer between 0-255\&.
.RE
.TP 2
.B
\fIdatetime()\fR\&:

.RS 2
.LP
{{Year,Month,Day}, {Hour,Minute,Second}} in local timezone\&.
.RE
.TP 2
.B
\fImouseState()\fR\&:

.RS 2
.LP
See #wxMouseState{} defined in wx\&.hrl
.RE
.TP 2
.B
\fIwxObject()\fR\&:

.RS 2
.LP
Opaque object
.RE
.TP 2
.B
\fIwx_env()\fR\&:

.RS 2
.LP
Wx process environment
.RE
.TP 2
.B
\fIwx_mem()\fR\&:

.RS 2
.LP
Wx memory area
.RE
.RE
.SH EXPORTS
.LP
.B
new() -> wxObject()
.br
.RS
.LP
Starts a wx server\&.
.RE
.LP
.B
new(Options::[Option]) -> wxObject()
.br
.RS
.LP
Starts a wx server\&. Option may be {debug, Level}, see debug/1\&.
.RE
.LP
.B
destroy() -> ok
.br
.RS
.LP
Stops a wx server\&.
.RE
.LP
.B
get_env() -> wx_env()
.br
.RS
.LP
Gets this process\&'s current wx environment\&. Can be sent to other processes to allow them use this process wx environment\&.
.LP
\fISee also:\fR\& \fBset_env/1\fR\&\&.
.RE
.LP
.B
set_env(Wx_env::wx_env()) -> ok
.br
.RS
.LP
Sets the process wx environment, allows this process to use another process wx environment\&.
.RE
.LP
.B
null() -> wxObject()
.br
.RS
.LP
Returns the null object
.RE
.LP
.B
is_null(Wx_ref::wxObject()) -> boolean()
.br
.RS
.LP
Returns true if object is null, false otherwise
.RE
.LP
.B
getObjectType(Wx_ref::wxObject()) -> atom()
.br
.RS
.LP
Returns the object type
.RE
.LP
.B
typeCast(Old::wxObject(), NewType::atom()) -> wxObject()
.br
.RS
.LP
Casts the object to class NewType\&. It is needed when using functions like wxWindow:findWindow/2, which returns a generic wxObject type\&.
.RE
.LP
.B
batch(Fun::function()) -> term()
.br
.RS
.LP
Batches all \fIwx\fR\& commands used in the fun\&. Improves performance of the command processing by grabbing the wxWidgets thread so that no event processing will be done before the complete batch of commands is invoked\&.
.LP
\fISee also:\fR\& \fBfoldl/3\fR\&, \fBfoldr/3\fR\&, \fBforeach/2\fR\&, \fBmap/2\fR\&\&.
.RE
.LP
.B
foreach(Fun::function(), List::list()) -> ok
.br
.RS
.LP
Behaves like \fBlists:foreach/2\fR\& but batches wx commands\&. See \fBbatch/1\fR\&\&.
.RE
.LP
.B
map(Fun::function(), List::list()) -> list()
.br
.RS
.LP
Behaves like \fBlists:map/2\fR\& but batches wx commands\&. See \fBbatch/1\fR\&\&.
.RE
.LP
.B
foldl(Fun::function(), Acc::term(), List::list()) -> term()
.br
.RS
.LP
Behaves like \fBlists:foldl/3\fR\& but batches wx commands\&. See \fBbatch/1\fR\&\&.
.RE
.LP
.B
foldr(Fun::function(), Acc::term(), List::list()) -> term()
.br
.RS
.LP
Behaves like \fBlists:foldr/3\fR\& but batches wx commands\&. See \fBbatch/1\fR\&\&.
.RE
.LP
.B
create_memory(Size::integer()) -> wx_memory()
.br
.RS
.LP
Creates a memory area (of Size in bytes) which can be used by an external library (i\&.e\&. opengl)\&. It is up to the client to keep a reference to this object so it does not get garbage collected by erlang while still in use by the external library\&.
.LP
This is far from erlang\&'s intentional usage and can crash the erlang emulator\&. Use it carefully\&.
.RE
.LP
.B
get_memory_bin(Wx_mem::wx_memory()) -> binary()
.br
.RS
.LP
Returns the memory area as a binary\&.
.RE
.LP
.B
retain_memory(Wx_mem::wx_memory()) -> ok
.br
.RS
.LP
Saves the memory from deletion until release_memory/1 is called\&. If release_memory/1 is not called the memory will not be garbage collected\&.
.RE
.LP
.B
release_memory(Wx_mem) -> term() 
.br
.RS
.RE
.LP
.B
debug(Level::term()) -> ok
.br
.RS
.TP 3
Types:

Level = none | verbose | trace | driver | [Level]
.br
.RE
.RS
.LP
Sets debug level\&. If debug level is verbose or trace each call is printed on console\&. If Level is driver each allocated object and deletion is printed on the console\&.
.RE
.LP
.B
demo() -> ok
.br
.RS
.LP
Starts a wxErlang demo if examples directory exists and is compiled
.RE
.SH AUTHORS
.LP

.I
<>