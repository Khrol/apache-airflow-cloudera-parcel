.TH inviso 3 "inviso 0.6.2" "Ericsson AB" "Erlang Module Definition"
.SH NAME
inviso \- Main API Module to the Inviso Tracer
.SH DESCRIPTION
.LP
With the \fIinviso\fR\& API runtime components can be started and tracing managed across a network of distributed Erlang nodes, using a control component also started with \fIinviso\fR\& API functions\&.
.LP
Inviso can be used both in a distributed environment and in a non-distributed\&. API functions not taking a list of nodes as argument works on all started runtime components\&. If it is the non-distributed case, that is the local runtime component\&. The API functions taking a list of nodes as argument, or as part of one of the arguments, can not be used in a non-distributed environment\&. Return values named \fINodeResult\fR\& refers to return values from a single Erlang node, and will therefore be the return in the non-distributed environment\&.
.SH EXPORTS
.LP
.B
start() -> {ok,pid()} | {error,Reason}
.br
.B
start(Options) -> {ok,pid()} | {error,Reason}
.br
.RS
.TP 3
Types:

Options = [Option]
.br
.RE
.RS
.LP
\fIOptions\fR\& may contain both options which will be default options to a runtime component when started, and options to the control component\&. See \fBadd_nodes/3\fR\& for details on runtime component options\&. The control component recognizes the following options:
.RS 2
.TP 2
.B
\fI{subscribe,Pid}\fR\&:
Making the process \fIPid\fR\& receive Inviso events from the control component\&.
.RS 2
.LP
Starts a control component process on the local node\&. A control component must be started before runtime components can be started manually or otherwise accessed through the \fIinviso\fR\& API\&.
.RE
.RE
.RE
.LP
.B
stop() -> shutdown
.br
.RS
.LP
Stops the control component\&. Runtime components are left as is\&. They will behave according to their dependency values\&.
.RE
.LP
.B
add_node(RTtag) -> NodeResult | {error,Reason}
.br
.B
add_node(RTtag,Options) -> NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

RTtag = PreviousRTtag = term()
.br
Options = [Option]
.br
Option -- see below
.br
Option = {dependency,Dep}
.br
Dep = int() | infinity
.br
The timeout, in milliseconds, before the runtime component will terminate if abandoned by \fIthis\fR\&control component\&.
.br
Option = {overload,Overload} | overload
.br
Controls how and how often overload checks shall be performed\&. Just \fIoverload\fR\&specifies that no loadcheck shall be performed\&.
.br
Overload = Interval | {LoadMF,Interval,InitMFA,RemoveMFA}
.br
LoadMF = {Mod,Func} | function()/1
.br
Interval = int() | infinity
.br
Interval is the time in milliseconds between overload checks\&.
.br
InitMFA = RemoveMFA = {Mod,Func,ArgList} | void
.br
When starting up the runtime component or when changing options (see \fIchange_options/2\fR\&) the overload mechanism is initialized with a call to the \fIInitMFA\fR\&function\&. It shall return \fILoadCheckData\fR\&\&. Every time a load check is performed, \fILoadMF\fR\&is called with \fILoadCheckData\fR\&as its only argument\&. \fILoadMF\fR\&shall return \fIok\fR\&or \fI{suspend,Reason}\fR\&\&. When the runtime component is stopped or made to change options involving changing overload-check, the \fIRemoveMFA\fR\&function is called\&. Its return value is discarded\&.
.br
NodeResult = {ok,NAns} | {error,Reason}
.br
NAns = new | {adopted,State,Status,PreviousRTtag} | already_added
.br
State = new | tracing | idle
.br
Status = running | {suspended,SReason}
.br
.RE
.RS
.LP
Starts or tries to connect to an existing runtime component at the local node, regardless if the system is distributed or not\&. \fIOptions\fR\& will override any default options specified at start-up of the control component\&.
.LP
The \fIPreviousRTtag\fR\& can indicate if the incarnation of the runtime component at the node in question was started by "us" and then can be expected to do tracing according to "our" instructions or not\&.
.RE
.LP
.B
add_node_if_ref(RTtag) -> NodeResult | {error,{wrong_reference,OtherTag}} | {error,Reason}
.br
.B
add_node_if_ref(RTtag,Options) -> NodeResult | {error,{wrong_reference,OtherRef}} | {error,Reason}
.br
.RS
.TP 3
Types:

OtherRef = term()
.br
rttag of the running incarnation
.br
.RE
.RS
.LP
As \fBadd_node/1,2\fR\& but will only adopt the runtime component if its rttag is \fIRTtag\fR\&\&.
.RE
.LP
.B
add_nodes(Nodes,RTtag) -> {ok,NodeResults} | {error,Reason}
.br
.B
add_nodes(Nodes,RTtag,Options) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeResults = [{Node,NodeResult}]
.br
.RE
.RS
.LP
As \fBadd_node/1,2\fR\& but for a distributed environment\&.
.RE
.LP
.B
add_nodes_if_ref(Nodes,RTtag) -> NodeResult | {error,Reason}
.br
.B
add_nodes_if_ref(Nodes,RTtag,Options) -> NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeResults = [{Node,NodeResult}]
.br
.RE
.RS
.LP
As \fBadd_node_if_ref/1,2\fR\& but for a distributed environment\&.
.RE
.LP
.B
stop_nodes() -> {ok,NodeResults} | NodeResult
.br
.B
stop_nodes(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Stops runtime component on \fINodes\fR\&\&. \fIstop_nodes/0\fR\& will if the control component is running on a distributed node stop all runtime components\&. And if running on a non distributed node, stop the local and only runtime component\&.
.RE
.LP
.B
stop_all() = {ok,NodeResults} | NodeResult
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
A combination of \fBstop/0\fR\& and \fBstop_nodes/0\fR\&\&.
.RE
.LP
.B
change_options(Options) -> NodeResult | {ok,NodeResults} | {error,Reason}
.br
.B
change_options(Nodes,Options) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Changes the options for one or several runtime components\&. If for instance overload is redefined, the previous overload will be stopped and the new started\&. See \fBadd_node/1\fR\& for details on \fIOptions\fR\&\&.
.RE
.LP
.B
init_tracing(TracerData) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
init_tracing(TracerList) -> {ok,NodeResults} | {error,Reason}
.br
.B
init_tracing(Nodes,TracerData) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

TracerData = [{trace,LogTD} [,{ti,TiTD}] }] | LogTD
.br
LogTD = {HandlerFun,Data1} | collector | {relayer,CollectingNode} | {ip,IPPortParameters} | {file,FilePortParameters}
.br
TiTD = {file,FileName} | {file,FileName,TiSpec} | {relay,Node}
.br
TiSpec = {InitMFA,RemoveMF,CleanMF}
.br
InitMFA = {Mi,Fi,Argsi}
.br
RemoveMF = {Mr,Fr} | void
.br
CleanMF = {Mc,Fc}
.br
Mi = Fi = Mr = Fr = Mc = Fd = atom()
.br
Argsi = [term()]
.br
TracerList = [{Node,TracerData}]
.br
IPPortParameters = Portno | {Portno,Qsize}
.br
Portno = tcp_portno()
.br
Qsize = int()
.br
FilePortParameters = {Filename,wrap,Tail,{time,WrapTime},WrapCnt} | {FileName,wrap,Tail,WrapSize,WrapCnt} | {FileName,wrap,Tail,WrapSize} | {FileName,wrap,Tail} | FileName
.br
FileName = string()
.br
Tail = string() =/= ""
.br
WrapTime = WrapCnt = WrapSize = int() >0
.br
TracerList = [{Node,TracerData}]
.br
Nodes = [Node]
.br
HandlerFun = function()/2;
.br
HandlerFun(TraceMsg,Data1) -> NewData
.br
CollectingNode = pid() | node()
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,LogResults} | {error,NReason}
.br
LogResults = [LogResult]
.br
LogResult = {trace_log,LogRes} | {ti_log,LogRes}
.br
LogRes = ok | {error,Reason}
.br
.RE
.RS
.LP
Starts the tracing at the specified nodes, meaning that the runtime components transits from the state \fInew\fR\& or \fIidle\fR\& to \fItracing\fR\&\&. For trace messages to be generated, there must of course also be trace pattern and/or trace flags set\&. Such can not be set before tracing has been initiated with \fIinit_tracing/1,2\fR\&\&.
.LP
\fITracerData\fR\& controls how the runtime component will handle generated trace messages\&. The \fItrace\fR\& tag controls how regular trace messages are handled\&. The \fIti\fR\& tag controls if and how trace information will be stored and the meta tracer will be activated\&. That is if \fIti\fR\& is omitted, no meta tracer will be started as part of the runtime component\&. It is possible to have \fIti\fR\& without \fItrace\fR\&, but most likely not useful\&.
.LP
The \fIip\fR\& and \fIfile\fR\& trace tracerdata instructions results in using the built in trace ip-port and file-port respectively\&. \fIrelayer\fR\& will result in that all regular trace messages are forwarded to a runtime component at the specified node\&. Using a \fIHandlerFun\fR\& will result in that every incoming regular trace message is applied to the \fIHandlerFun\fR\&\&. \fIcollector\fR\& can be used to use this runtime component to receive relayed trace messages and print them to the shell\&.
.LP
The trace information can be configured to either write trace information to a plain trace information file or to relay it to another inviso meta tracer on another node\&. The inviso meta tracer is capable of matching function calls with their function returns (only if \fIreturn_trace\fR\& is activated in the meta trace match specification for the function in question)\&. This is necessary since it may not be possible to decide what to do, if anything shall be done at all, until the return value of the function call is examined\&.
.LP
To be able to match calls with returns a state can be saved when detecting a function call in a public loop data structure kept by the inviso meta tracer\&. The public loop data structure is given as argument to a handler-function called whenever a meta trace message arrives to the inviso meta tracer (both function calls and function returns)\&. The public loop data structure is first initiated by the \fIMi:Fi\fR\& function which takes the items in \fIArgsi\fR\& as arguments\&. \fIFi\fR\& shall return the initial public loop data structure\&. When meta tracing is stopped, either because tracing is stopped or because tracing is suspended, the \fIMr:Fr(PublicLoopData)\fR\& is called to offer a possibility to clean-up\&. Note that for every function meta-tracing is activated, a public loop data modification function can be specified\&. That function will prepare the current loop data structure for this particular function\&.
.LP
Further there is a risk that function call states becomes abandoned inside the public loop data structure\&. This will happen if a function call is entered into the public loop data structure, but no function return occurs\&. To prevent the public loop data structure from growing infinitely the clean function \fIFc\fR\& will periodically be called with the public loop data structure as argument\&. Elements entered into the public loop data structure as a result of a function call must contain a timestamp for the \fIFc\fR\& to be able to conclude if it is abandoned or not\&. \fIFc\fR\& shall return a new public loop data structure\&.
.LP
When initiating tracing involving trace information without a \fITiSpec\fR\&, a default public loop data structure will be initiated to handle locally registered process aliases\&. The default public loop data structure is a two-tuple where the first element is used by the meta tracing on the BIF \fIregister/2\fR\&\&. The second element is left for user usage\&.
.LP
The default public loop data structure may be extended with more element positions\&. The first position must be left to the implementation of registered-name translations\&. If the public loop data structure is changed no longer meeting this requirement, the \fBtpm_localnames/0,1\fR\& and \fBtpm_globalnames/0,1\fR\& can no longer be used\&.
.LP
A wrap files specification is used to limit the disk space consumed by the trace\&. The trace is written to a limited number of files each with a limited size\&. The actual filenames are \fIFilename ++ SeqCnt ++ Tail\fR\&, where \fISeqCnt\fR\& counts as a decimal string from 0 to \fIWrapCnt\fR\& and then around again from 0\&. When a trace message written to the current file makes it longer than \fIWrapSize\fR\&, that file is closed, if the number of files in this wrap trace is as many as \fIWrapCnt\fR\& the oldest file is deleted then a new file is opened to become the current\&. Thus, when a wrap trace has been stopped, there are at most \fIWrapCnt\fR\& trace files saved with a size of at least \fIWrapSize\fR\& (but not much bigger), except for the last file that might even be empty\&. The default values are \fIWrapSize == 128*1024\fR\& and \fIWrapCnt == 8\fR\&\&.
.LP
The \fISeqCnt\fR\& values in the filenames are all in the range 0 through \fIWrapCnt\fR\& with a gap in the circular sequence\&. The gap is needed to find the end of the trace\&.
.LP
If the \fIWrapSize\fR\& is specified as \fI{time,WrapTime}\fR\&, the current file is closed when it has been open more than \fIWrapTime\fR\& milliseconds, regardless of it being empty or not\&.
.LP
The ip trace driver has a queue of \fIQSize\fR\& messages waiting to be delivered\&. If the driver cannot deliver messages as fast as they are produced by the runtime system, they are dropped\&. The number of dropped messages are indicated in the trace log as separate trace message\&.
.RE
.LP
.B
stop_tracing(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.B
stop_tracing() -> {ok,NodeResults} | NodeResult
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,State} | {error,Reason}
.br
State = new | idle
.br
.RE
.RS
.LP
Stops tracing on all or specified \fINodes\fR\&\&. Flushes the trace buffer if a trace-port is used, closes the trace-port and removes all trace flags and meta-patterns\&. The nodes are called in parallel\&.
.LP
Stopping tracing means going to state \fIidle<c>\&. If the runtime component was already in state <c>new\fR\&, it will of course remain in state \fInew\fR\& (then there was no tracing to stop)\&.
.RE
.LP
.B
clear() -> {ok,NodeResults} | NodeResult
.br
.B
clear(Nodes,Options) -> {ok,NodeResults} | {error,Reason}
.br
.B
clear(Options) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
Options = [Option]
.br
Option = keep_trace_patterns | keep_log_files
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,{new,Status}} | {error,Reason}
.br
Status = running | {suspended,SReason}
.br
.RE
.RS
.LP
Stops all tracing including removing meta-trace patterns\&. Removes all trace patterns\&. If the node is \fItracing\fR\& or \fIidle\fR\&, trace-logs belonging to the current tracerdata are removed\&. Hence the node is returned to state \fInew\fR\&\&. Note that the node can still be suspended\&.
.LP
Various options can make the node keep set trace patterns and log-files\&. The node still enters the \fInew\fR\& state\&.
.RE
.LP
.B
tp(Nodes,Mod,Func,Arity,MatchSpec,Opts) -> 
.br
.B
tp(Nodes,Mod,Func,Arity,MatchSpec) -> {ok,NodeResults} | {error,Reason}
.br
.B
tp(Mod,Func,Arity,MatchSpec,Opts) -> 
.br
.B
tp(Mod,Func,Arity,MatchSpec) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tp(Nodes,PatternList) -> {ok,NodeResults} | {error,Reason}
.br
.B
tp(PatternList) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
Mod = Func = atom() | '_'
.br
Arity = int() | '_'
.br
MatchSpec = true | false | [] | matchspec()
.br
PatternList = [Pattern],
.br
Pattern = {Mod,Func,Arity,MatchSpec,Opts}
.br
Opts = [Opt]
.br
Opt = only_loaded
.br
NodeResults = [NodeResult]
.br
NodeResult = {ok,[Ans]} | {error,Reason}
.br
Ans = int() | {error,Reason}
.br
.RE
.RS
.LP
Set trace pattern (global) on specified or all nodes\&. The integer replied if the call was successfully describes the number of matched functions\&. The functions without a \fINodes\fR\& argument means all nodes, in a non-distributed environment it means the local node\&. Using wildcards follows the rules for wildcards of \fIerlang:trace_pattern/3\fR\&\&. It is for instance illegal to specify \fIM == \&'_\&'\fR\& while \fIF\fR\& is not \fI\&'_\&'\fR\&\&.
.LP
When calling several nodes, the nodes are called in parallel\&.
.LP
The option \fIonly_loaded\fR\& will prevent modules not loaded (yet) into the runtime system to become loaded just as a result of that a trace pattern is requested to be set on it\&. Otherwise modules are automatically loaded if not already loaded (since the module must be present for a trace pattern to be set on it)\&. The latter does not apply if the wildcard \fI\&'_\&'\fR\& is used as module specification\&.
.RE
.LP
.B
tpl(Nodes,Mod,Func,Arity,MatchSpec) -> 
.br
.B
tpl(Nodes,Mod,Func,Arity,MatchSpec,Opts) -> {ok,NodeResults} | {error,Reason}
.br
.B
tpl(Mod,Func,Arity,MatchSpec) -> 
.br
.B
tpl(Mod,Func,Arity,MatchSpec,Opts) -> {ok,NodeResults} | NodeResult| {error,Reason}
.br
.B
tpl(Nodes,PatternList) -> {ok,NodeResults} | {error,Reason}
.br
.B
tpl(PatternList) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.LP
See \fBtp/N\fR\& function above for details on arguments and return values\&.
.LP
Set local trace pattern on specified functions\&. When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
ctp(Nodes,Mod,Func,Arity) -> {ok,NodeResults} | {error,Reason}
.br
.B
ctp(Mod,Func,Arity) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.LP
See \fBtp/N\fR\& for argument descriptions\&.
.LP
Clear global trace patterns\&. When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
ctpl(Nodes,Mod,Func,Arity) -> {ok,NodeResults} | {error,Reason}
.br
.B
ctpl(Mod,Funct,Arity) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.LP
See \fBtp/N\fR\& for argument description\&.
.LP
Clear local trace patterns\&. When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
tf(Nodes,PidSpec,FlagList) -> {ok,NodeResults} | {error,Reason}
.br
.B
tf(PidSpec,FlagList) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tf(Nodes,TraceConfList) -> {ok,NodeResults} | {error,Reason}
.br
.B
tf(NodeTraceConfList) -> {ok,NodeResults} | {error,Reason}
.br
.B
tf(TraceConfList) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeTraceConfList = [{Node,TraceConfList}]
.br
TraceConfList = [{PidSpec,FlagList}]
.br
FlagList = [Flag]
.br
PidSpec = all | new| existing | pid() | locally_registered_name()
.br
Flag -- see erlang:trace/3
.br
NodeResult = {ok,[Ans]} | {error,Reason}
.br
Ans = int() | {error,Reason}
.br
.RE
.RS
.LP
Set process trace flags on processes on all or specified nodes\&. The integer returned if the call was successful describes the matched number of processes\&. The functions without a \fINodes\fR\& argument means all nodes, in a non-distributed environment it means the local node\&.
.LP
There are many combinations which does not make much sense\&. For instance specifying a certain process identifier at all nodes\&. Or an empty \fITraceConfList\fR\& for all nodes\&.
.LP
When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
ctf(Nodes,PidSpec,FlagList) -> {ok,NodeResults} | {error,Reason}
.br
.B
ctf(PidSpec,FlagList) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
ctf(Nodes,TraceConfList) -> {ok,NodeResults} | {error,Reason}
.br
.B
ctf(TraceConfList) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.LP
See \fBtf/N\fR\& for arguments and return value description\&.
.LP
Clear process trace flags on all or specified nodes\&. When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
ctf_all(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.B
ctf_all() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Clears all trace flags on all or specified nodes\&. Just for convenience\&.
.RE
.LP
.B
init_tpm(Mod,Func,Arity,CallFunc) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
init_tpm(Nodes,Mod,Func,Arity,CallFunc) -> {ok,NodeResults} | {error,Reason}
.br
.B
init_tpm(Mod,Func,Arity,InitFunc,CallFunc,ReturnFunc,RemoveFunc) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
init_tpm(Nodes,Mod,Func,Arity, InitFunc,CallFunc,ReturnFunc,RemoveFunc) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

Mod = Func = atom()
.br
Arity = int()
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
InitFunc,RemoveFunc = {Module,Function} | function()/4 | void
.br
CallFunc = ReturnFunc = {Module,Function} | function()/3 | void
.br
.RE
.RS
.LP
Initializes \fIMod:Func/Arity\fR\& for meta tracing without setting any meta trace patterns\&. This is necessary if the named match specs will be used (see \fBtpm_ms/5,6\fR\&)\&. Otherwise initialization of public loop data can be done at the same time as setting meta trace patterns using \fBtpm/8,9\fR\&\&.
.LP
Note that we can not use wildcards here (even if it is perfectly legal in Erlang)\&. It also sets the \fICallFunc\fR\& and \fIReturnFunc\fR\& for the meta traced function\&. That is the functions which will be called when a function call and a return_trace meta trace message respectively arrives to the inviso meta tracer for \fIMod:Func/Arity\fR\&\&.
.LP
This function is also available without \fIInitFunc\fR\& and \fIRemoveFunc\fR\&\&. That means that no initialization of the public loop data structure will be done and that \fICallFunc\fR\& and \fIReturnFunc\fR\& must either use already existing parts of public loop data structure or not use it at all\&.
.LP
The \fIInitFunc\fR\& initializes the already existing public loop data structure for use with \fIMod:Func/Arity\&. InitFunc(Mod,Func,Arity,PublLD) -> {ok,NewPublLD,Output}\fR\& where \fIOutPut\fR\& can be a binary which will then be written to the trace information file\&. If it is not a binary, no output will be done\&. \fIRemoveFunc\fR\& will be called when the meta tracing is cleared with \fBctpm/3,4\fR\&\&. \fIRemoveFunc(Mod,Func,Arity,PublLD) -> {ok,NewPublLD}\fR\&\&.
.LP
See \fBtpm/N\fR\& for details on \fICallFunc\fR\& and \fIReturnFunc\fR\&\&.
.RE
.LP
.B
tpm(Mod,Func,Arity,MS) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tpm(Nodes,Mod,Func,Arity,MS) -> {ok,NodeResults} | {error,Reason}
.br
.B
tpm(Mod,Func,Arity,MS,CallFunc) -> {ok,NodeResults} | NodeResults | {error,Reason}
.br
.B
tpm(Nodes,Mod,Func,Arity,MS,CallFunc) -> {ok,NodeResults} | {error,Reason}
.br
.B
tpm(Mod,Func,Arity,MS,InitFunc,CallFunc,ReturnFunc,RemoveFunc) -> {ok,NodeResults} | NodeResults | {error,Reason}
.br
.B
tpm(Nodes,Mod,Func,Arity,MS, InitFunc,CallFunc,ReturnFunc,RemoveFunc) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

Mod = Func = atom()
.br
Arity = int()
.br
MS = [match_spec()]
.br
Nodes = [Node]
.br
InitFunc = RemoveFunc = {Module,Function} | function()/4 | void
.br
CallFunc = ReturnFunc = {Module,Function} | function()/3 | void
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,1} | {ok,0} | {error,Reason}1
.br
.RE
.RS
.LP
Activates meta-tracing in the inviso_rt_meta tracer\&. Except when using \fItpm/6\fR\&, \fItpm/8\fR\& and \fItpm/9\fR\& the \fIMod:Func/Arity\fR\& must first have been initiated using \fBinit_tpm/N\fR\&\&. When calling several nodes, the nodes are called in parallel\&.
.LP
\fICallFunc\fR\& will be called every time a meta trace message arrives to the inviso meta tracer because of a call to \fIFunc\fR\&\&. \fICallFunc(CallingPid,ActualArgList,PublLD) -> {ok,NewPrivLD,Output}\fR\& where \fIOutput\fR\& can be a binary or \fIvoid\fR\&\&. If it is a binary it will be written to the trace information file\&.
.LP
\fIReturnFunc\fR\& will be called every time a meta return_trace message arrives to the inviso meta tracer because of a return_trace of a call to \fIFunc\fR\&\&. \fIReturnFunc(CallingPid,ReturnValue,PublLD) -> {ok,NewPrivLD,Output}\fR\&\&. Further the \fIReturnFunc\fR\& must handle the fact that a return_trace message arrives for a call which was never noticed\&. This because the message queue of the meta tracer may have been emptied\&.
.RE
.LP
.B
tpm_tracer(Mod,Func,Arity,MS) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tpm_tracer(Nodes,Mod,Func,Arity,MS) -> {ok,NodeResults} | {error,Reason}
.br
.B
tpm_tracer(Mod,Func,Arity,MS,CallFunc) -> {ok,NodeResults} | NodeResults | {error,Reason}
.br
.B
tpm_tracer(Nodes,Mod,Func,Arity,MS,CallFunc) -> {ok,NodeResults} | {error,Reason}
.br
.B
tpm_tracer(Mod,Func,Arity,MS,InitFunc,CallFunc,ReturnFunc,RemoveFunc) -> {ok,NodeResults} | NodeResults | {error,Reason}
.br
.B
tpm_tracer(Nodes,Mod,Func,Arity,MS, InitFunc,CallFunc,ReturnFunc,RemoveFunc) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.LP
See tpm/X for details on arguments and return values\&.
.LP
Same as tpm/X but all match specs in \fIMS\fR\& containing a \fItrace\fR\& action term will have a \fI{tracer,Tracer}\fR\& appended to its enable-list\&. \fITracer\fR\& will be the current output for regular trace messages as specified when tracing was initiated\&. This function is useful when setting a meta trace pattern on a function with the intent that its execution shall turn tracing on for the process executing the match-spec in the meta trace pattern\&. The reason the \fItracer\fR\& process trace flag can not be explicitly written in the action term by the user is that it may be difficult to learn its exact value for a remote node\&. Further more inviso functions are made to work on several nodes at the same time, requiring different match specs to be set for different nodes\&.
.LP
Simple example: We want any process executing the function \fImymod:init(1234)\fR\& (with the argument, exactly the integer 1234) to begin function-call tracing\&. In the example, if the process is found to be one that shall start call tracing, we also first disable \fIall\fR\& process trace flags to ensure that we have full control over what the process traces\&. \fIvoid\fR\& in the example specifies that the meta-tracer (inviso_rt_meta) will not call any function when meta trace messages for \fImymod:init/1\fR\& arrives\&. There is no need for a \fICallFunc\fR\& since the side-effect (start call-tracing) is achieved immediately with the match-spec\&.
.LP
.nf

    inviso:tpm_tracer(mymod,init,1,[{[1234],[],[{trace,[all],[call]}]}],void).        
.fi
.LP
This will internally, by the meta tracer on each Erlang node, be translated to:
.LP
.nf

    erlang:trace_pattern({mymod,init,1},[{[1234],[],[{trace,[all],[call,{{tracer,T}}]}]}],[{meta,P}]).
        
.fi
.LP
Where \fIT\fR\& is the tracer for regular trace messages (most often a trace-port, but can be the runtime component inviso_rt process), and \fIP\fR\& is the meta tracer (the inviso_rt_meta process)\&.
.RE
.LP
.B
tpm_ms(Mod,Func,Arity,MSname,MS) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tpm_ms(Nodes,Mod,Func,Arity,MSname,MS) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]<v> <v>Mod = Func = atom()<v> <v>Arity = int()<v> <v>MSname = term()<v> <v>MS = [match_spec()]<v> <v>NodeResults = [{Node,NodeResult}]<v> <v>NodeResult = {ok,1} | {ok,0} | {error,Reason}<v>
.br
.RE
.RS
.LP
This function adds a list of match-specs to the already existing ones\&. It uses an internal database to keep track of existing match-specs\&. This set of match specs can hereafter be referred to with the name \fIMSname\fR\&\&. If the match-spec does not result in any meta traced functions (for whatever reason), the \fIMS\fR\& is not saved in the database\&. The previously known match-specs are not removed\&. If \fIMSname\fR\& is already in use as a name referring to a set of match-specs for this particular meta-traced function, the previous set of match-specs are replaced with \fIMS\fR\&\&.
.LP
\fIMod:Func/Arity\fR\& must previously have been initiated in order for this function to add a match-spec\&.
.LP
When calling several nodes, the nodes are called in parallel\&. \fI{ok,1}\fR\& indicates success\&.
.RE
.LP
.B
tpm_ms_tracer(Mod,Func,Arity,MSname,MS) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tpm_ms_tracer(Nodes,Mod,Func,Arity,MSname,MS) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.LP
See tpm_ms/X for details on arguments and return values, and tpm_tracer/X for explanations about the appending of \fI{tracer,Tracer}\fR\& process trace flag\&.
.RE
.LP
.B
ctpm_ms(Mod,Func,Arity,MSname) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
ctpm_ms(Nodes,Mod,Func,Arity,MSname) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Removes a named match-spec from the meta traced function\&. Note that it never is a fault to remove a match spec\&. Not even from a function which is non existent\&.
.LP
When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
ctpm(Mod,Func,Arity) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
ctpm(Nodes,Mod,Func,Arity) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Removes the meta trace pattern for the function, means stops generating output for this function\&. The public loop data structure may be cleared by the previously entered \fIRemoveFunc\fR\&\&.
.LP
When calling several nodes, the nodes are called in parallel\&.
.RE
.LP
.B
tpm_localnames() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tpm_localnames(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = {R1,R2}
.br
R1 = R2 = {ok,0} | {ok,1} | {error,Reason}
.br
.RE
.RS
.LP
Quick version for setting meta-trace patterns on \fIerlang:register/2\fR\&\&. It uses a default \fICallFunc\fR\& and \fIReturnFunc\fR\& in the meta-tracer server\&. The main purpose of this function is to create ti-log entries for associations between pids and registered name aliases\&. The implementation uses return_trace to see if the registration was successful or not, before actually making the ti-log alias entry\&. Further the implementation also meta traces the BIF \fIunregister/1\fR\&\&.
.LP
If both \fIN1\fR\& and \fIN2\fR\& is 1, function call was successful\&. \fIN1\fR\& and \fIN2\fR\& represent setting meta trace pattern on \fIregister/2\fR\& and \fIunregister/1\fR\&\&.
.RE
.LP
.B
ctpm_localnames() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
ctpm_localnames(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = {R1,R2}
.br
R1 = R2 = ok | {error,Reason}
.br
.RE
.RS
.LP
Function for removing previously set patters by \fBtpm_localnames/0\fR\&\&. The two results \fIR1\fR\& and \fIR2\fR\& represents that meta pattern is removed from both \fIregister/2\fR\& and \fIunregister/1\fR\&\&.
.RE
.LP
.B
tpm_globalnames() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
tpm_globalnames(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = {R1,R2}
.br
R1 = R2 = {ok,0} | {ok,1} | {error,Reason}
.br
.RE
.RS
.LP
Quick version for setting meta-trace patterns capable of learning the association of a pid with a globally registered name (registered using \fIglobal:register_name\fR\&)\&. The implementation meta-traces on \fIglobal:handle_call({register,\&'_\&',\&'_\&',\&'_\&'},\&'_\&',\&'_\&')\fR\& and \fIglobal:delete_global_name/2\fR\&\&. The \fIN1\fR\& and \fIN2\fR\& represents the success of the two sub-tmp calls\&.
.RE
.LP
.B
ctpm_globalnames() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
ctpm_globalnames(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = {R1,R2} | {error,Reason}
.br
R1 = R2 = ok | {error,Reason}
.br
.RE
.RS
.LP
Function for removing previously set meta patters by \fBtpm_globalnames/0,1\fR\&\&. The two results \fIR1\fR\& and \fIR2\fR\& represents that meta pattern are removed from both \fIglobal:handle_call/3\fR\& and \fIglobal:delete_global_name/1\fR\&\&.
.RE
.LP
.B
ctp_all() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
ctp_all(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Clears all, both global and local trace patterns\&. Does not clear meta trace patterns\&. Equivalent to a call to \fBctp/3,4\fR\& and to \fBctpl/3,4\fR\& with wildcards \fI\&'_\&'\fR\& for all modules, functions and arities\&.
.RE
.LP
.B
suspend(SReason) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
suspend(Nodes,SReason) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

SReason = term()
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Suspends the runtime components\&. \fISReason\fR\& will become the suspend-reason replied in for instance a \fBget_status/0,1\fR\& call\&. A runtime component that becomes suspended removes all trace flags and all meta trace patterns\&. In that way trace output is no longer generated\&. The task of reactivating a suspended runtime component is outside the scoop of inviso\&. It can for instance be implemented by a higher layer trace-tool "remembering" all trace flags and meta patterns set\&.
.RE
.LP
.B
cancel_suspension() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
cancel_suspend(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = ok | {error,Reason}
.br
.RE
.RS
.LP
Makes the runtime components \fIrunning\fR\& again (as opposite to \fIsuspended)\&.\fR\& Since reactivating previous trace flags and meta trace patterns is outside the scoop of inviso, cancelling suspension is simply making it possible to set trace flags and meta trace patterns again\&.
.RE
.LP
.B
get_status() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
get_status(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,{State,Status}} | {error,Reason}
.br
State = new | idle | tracing
.br
Status = running | {suspended,SReason}
.br
SReason = term()
.br
.RE
.RS
.LP
Finds out the state and status of a runtime component\&. A runtime component is in state \fInew\fR\& before it has been initiated to do any tracing the first time\&. There are clear-functions which can make a runtime component become \fInew\fR\& again without having to restart\&. A runtime component becomes \fIidle\fR\& after tracing is stopped\&.
.RE
.LP
.B
get_tracerdata() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
get_tracerdata(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.RS
.TP 3
Types:

NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,NResult} | {error,Reason}
.br
NResult = TracerData | no_tracerdata
.br
.RE
.RS
.LP
Returns the current tracerdata of a runtime component\&. A runtime component in state \fInew\fR\& can not have tracerdata\&. An \fIidle\fR\& runtime component does have tracerdata, the last active tracerdata\&. \fITracerData\fR\& will be a term as specified to \fIinit_tracing\fR\& when tracing was initiated for the runtime component\&.
.RE
.LP
.B
list_logs() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
list_logs(Nodes) -> {ok,NodeResults} | {error,Reason}
.br
.B
list_logs(NodeTracerData) -> {ok,NodeResults} | {error,Reason}
.br
.B
list_logs(TracerData) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

TracerData -- see init_tracing/1,2
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,FileList} | {ok,no_log} | {error,Reason}
.br
FileList = [FileType]
.br
FileType = {trace_log,Dir,Files} | {ti_log,Dir,Files}
.br
Files = [FileNameWithOutPath]
.br
.RE
.RS
.LP
Returns the actually existing log files associated with \fITracerData\fR\&\&. If a tracerdata is not specified, current tracerdata is used for that particular runtime component\&. \fIFiles\fR\& will be a list of one or more files should it be a wrap-set\&. Otherwise the it is a list of only one filename\&.
.LP
This function is useful to learn the name and path of all files belonging to a trace\&. This information can later be used to move those files for merging\&. Note that since it is possible to ask on other tracerdata than the current, it is possible to learn filenames of previously done traces, under the circumstances that they have not been removed\&.
.RE
.LP
.B
fetch_log(LogSpecList,DestDir,Prefix) -> {ok,NodeResults} | {error,not_distributed} | {error,Reason} 
.br
.B
fetch_log(DestDir,Prefix) -> {ok,NodeResults} | {error,not_distributed} | {error,Reason}
.br
.RS
.TP 3
Types:

DestDir = string()
.br
Prefix = string()
.br
LogSpecList = [LogSpec]
.br
LogSpec = {Node,FileSpecList} | Node | {Node,TracerData}
.br
TracerData = see init_tracing/1,/2
.br
FileSpecList = [{trace_log,Dir,FileList},{ti_log,Dir,FileList}] | [{trace_log,Dir,FileList}]
.br
FileList = [RemoteFileName]
.br
NodeResult = {Conclusion,ResultFileSpec} | no_log | {error,NReason}
.br
NReason = own_node | Reason
.br
Conclusion = complete | incomplete
.br
ResultFileSpec = [{trace_log,FileResults},{ti_log,FileResults}]
.br
FileResults = [FileResult]
.br
FileResult = {ok,FileName} | {error,FReason}
.br
FReason = {file_open,{posix(),FileName}} | {file_open,{posix(),RemoteFileName}} | {file_open,{posix(),[DestDir,Prefix,RemoteFileName]}} | {file_write,{posix(),FileName}} | {truncated,FileName} | {truncated,{Reason,FileName}}
.br
posix() = atom()
.br
.RE
.RS
.LP
Copies log files over distributed erlang to the control component node\&. This function can only be used in a distributed system\&.
.LP
The resulting transferred files will have the prefix \fIPrefix\fR\& and will be located in \fIDestDir\fR\&\&. The source files can either be pointed out using a \fIFileListSpec\fR\& or tracerdata\&. If no files are explicitly specified, current tracerdata for that node will be used\&. Note that if source files have the same name (on several nodes) they will overwrite each other at \fIDestDir\fR\&\&.
.RE
.LP
.B
delete_log(Nodes,TracerData) -> {ok,NodeResults} | {error,Reason}
.br
.B
delete_log(NodeSpecList) -> {ok,NodeResults} | {error,Reason}
.br
.B
delete_log(Spec) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
delete_log(TracerData) -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.B
delete_log() -> {ok,NodeResults} | NodeResult | {error,Reason}
.br
.RS
.TP 3
Types:

Nodes = [Node]
.br
NodeSpecList = [{Node,Spec}]
.br
Spec = [AbsPathFileName] | LogSpecs
.br
LogSpecs = [LogSpec]
.br
LogSpec = {trace_log,Dir,[FileNameWithoutPath]} | {ti_log,Dir,[FileNameWithoutPath]}
.br
TracerData -- see init_tracing/1,/2
.br
NodeResults = [{Node,NodeResult}]
.br
NodeResult = {ok,no_log} | {ok,LogInfos} | {ok,FileInfos}
.br
LogInfos = [LogInfo]
.br
LogInfo = {trace_log,FileInfos} | {ti_log,FileInfos}
.br
FileInfos = [FileInfo]
.br
FileInfo = {ok,FileName} | {error,Reason}
.br
.RE
.RS
.LP
Deletes listed files or files corresponding to tracerdata\&. If no tracerdata or list of files are specified in the call, current tracerdata at the runtime components will be used to identify files to delete\&. All filenames shall be strings\&.
.LP
\fIFileName\fR\& can either be an absolute path or just a filename depending on if \fIAbsPathFileName\fR\& or a \fILogSpec\fR\& was used to identify the file\&.
.RE
.LP
.B
subscribe() -> ok | {error,Reason}
.br
.B
subscribe(Pid) -> ok | {error,Reason}
.br
.RS
.TP 3
Types:

Pid = pid()
.br
.RE
.RS
.LP
Adds \fIPid\fR\& or \fIself()\fR\& if using \fIsubscribe/0\fR\& to the inviso-event sending list\&. Note that it is possible to add a pid several times and that the \fIPid\fR\& then will receive multiple copies of inviso-event messages\&.
.LP
All events will be sent to all subscribers in the event sending list\&.
.LP
.nf

Event = {inviso_event,ControllerPid,erlang:localtime(),Msg}
  Msg = {connected, Node, {RTtag, {State,Status}}}
      | {disconnected, Node, NA}
      | {state_change,Node,{State,Status}}
      | {port_down,Node,Reason}
    Node = node() | local_runtime
        
.fi
.LP
Subscribing to inviso-event may be necessary for a higher layer trace-tool using inviso to follow the runtime components\&. \fIlocal_runtime\fR\& will be used for a runtime component running in a non-distributed environment\&.
.RE
.LP
.B
unsubscribe() -> ok
.br
.B
unsubscribe(Pid) -> ok
.br
.RS
.LP
Removes \fIPid\fR\& (once) from the subscription list\&.
.RE