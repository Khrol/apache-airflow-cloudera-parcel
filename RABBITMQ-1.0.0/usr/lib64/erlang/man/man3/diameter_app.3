.TH diameter_app 3 "diameter 0.10" "Ericsson AB" "Erlang Module Definition"
.SH NAME
diameter_app \- 
Callback module of a Diameter application.
.SH DESCRIPTION
.LP
A diameter service as started by \fBdiameter:start_service/2\fR\& configures one of more Diameter applications, each of whose configuration specifies a callback that handles messages specific to its application\&. The messages and AVPs of the Diameter application are defined in a dictionary file whose format is documented in \fBdiameter_dict(4)\fR\& while the callback module is documented here\&. The callback module implements the Diameter application-specific functionality of a service\&.
.LP
A callback module must export all of the functions documented below\&. The functions themselves are of three distinct flavours:
.RS 2
.TP 2
*
\fBpeer_up/3\fR\& and \fBpeer_down/3\fR\& signal the attainment or loss of connectivity with a Diameter peer\&.
.LP
.TP 2
*
\fBpick_peer/4\fR\&, \fBprepare_request/3\fR\&, \fBprepare_retransmit/3\fR\&, \fBhandle_answer/4\fR\& and \fBhandle_error/4\fR\& are (or may be) called as a consequence of a call to \fBdiameter:call/4\fR\& to send an outgoing Diameter request message\&.
.LP
.TP 2
*
\fBhandle_request/3\fR\& is called in response to an incoming Diameter request message\&.
.LP
.RE

.LP

.RS -4
.B
Note:
.RE
The arities given for the the callback functions here assume no extra arguments\&. All functions will also be passed any extra arguments configured with the callback module itself when calling \fBdiameter:start_service/2\fR\& and, for the call-specific callbacks, any extra arguments passed to \fBdiameter:call/4\fR\&\&.

.SH "DATA TYPES"

.RS 2
.TP 2
.B
\fIcapabilities() = #diameter_caps{}\fR\&:
A record containing the identities of the local and remote Diameter peers having an established transport connection, as well as the capabilities as determined by capabilities exchange\&. Each field of the record is a 2-tuple consisting of values for the (local) host and (remote) peer\&. Optional or possibly multiple values are encoded as lists of values, mandatory values as the bare value\&.
.TP 2
.B
\fImessage() = record() | list()\fR\&:
The representation of a Diameter message as passed to \fBdiameter:call/4\fR\&\&. The record representation is as outlined in \fBdiameter_dict(4)\fR\&: a message as defined in a dictionary file is encoded as a record with one field for each component AVP\&. Equivalently, a message can also be encoded as a list whose head is the atom-valued message name (the record name minus any prefix specified in the relevant dictionary file) and whose tail is a list of \fI{FieldName, FieldValue}\fR\& pairs\&.
.RS 2
.LP
A third representation allows a message to be specified as a list whose head is a \fIdiameter_header\fR\& record and whose tail is a list of \fIdiameter_avp\fR\& records\&. This representation is used by diameter itself when relaying requests as directed by the return value of a \fBhandle_request/3\fR\& callback\&. It differs from the other other two in that it bypasses the checks for messages that do not agree with their definitions in the dictionary in question (since relays agents must handle arbitrary request): messages are sent exactly as specified\&.
.RE
.TP 2
.B
\fIpacket() = #diameter_packet{}\fR\&:
A container for incoming and outgoing Diameters message that\&'s passed through encode/decode and transport\&. Fields of a packet() record should not be set in return values except as documented\&.
.TP 2
.B
\fIpeer_ref() = term()\fR\&:
A term identifying a transport connection with a Diameter peer\&. Should be treated opaquely\&.
.TP 2
.B
\fIpeer() = {peer_ref(), capabilities()}\fR\&:
A tuple representing a Diameter peer connection\&.
.TP 2
.B
\fIservice_name() = term()\fR\&:
The service supporting the Diameter application\&. Specified to \fBdiameter:start_service/2\fR\& when starting the service\&.
.TP 2
.B
\fIstate() = term()\fR\&:
The state maintained by the application callback functions \fBpeer_up/3\fR\&, \fBpeer_down/3\fR\& and (optionally) \fBpick_peer/4\fR\&\&. The initial state is configured in the call to \fBdiameter:start_service/2\fR\& that configures the application on a service\&. Callback functions returning a state are evaluated in a common service-specific process while those not returning state are evaluated in a request-specific process\&.
.RE
.SH EXPORTS
.LP
.B
Mod:peer_up(SvcName, Peer, State) -> NewState
.br
.RS
.TP 3
Types:

SvcName = service_name()
.br
Peer = peer()
.br
State = NewState = state()
.br
.RE
.RS
.LP
Invoked when a transport connection has been established and a successful capabilities exchange has indicated that the peer supports the Diameter application of the application on which the callback module in question has been configured\&.
.RE
.LP
.B
Mod:peer_down(SvcName, Peer, State) -> NewState
.br
.RS
.TP 3
Types:

SvcName = service_name()
.br
Peer = peer()
.br
State = NewState = state()
.br
.RE
.RS
.LP
Invoked when a transport connection has been lost following a previous call to \fBpeer_up/3\fR\&\&.
.RE
.LP
.B
Mod:pick_peer(Candidates, Reserved, SvcName, State) -> {ok, Peer} | {Peer, NewState} | false
.br
.RS
.TP 3
Types:

Candidates = [peer()]
.br
Peer = peer() | false
.br
SvcName = service_name()
.br
State = NewState = state()
.br
.RE
.RS
.LP
Invoked as a consequence of a call to \fBdiameter:call/4\fR\& to select a destination peer for an outgoing request, the return value indicating the selected peer\&. A new application state can also be returned but only if the Diameter application in question was configured with the option \fIcall_mutates_state\fR\& set to \fItrue\fR\&, as documented for \fBdiameter:start_service/2\fR\&\&.
.LP
The candidate peers list will only include those which are selected by any \fIfilter\fR\& option specified in the call to \fBdiameter:call/4\fR\&, and only those which have indicated support for the Diameter application in question\&. The order of the elements is unspecified except that any peers whose Origin-Host and Origin-Realm matches that of the outgoing request (in the sense of a \fI{filter, {all, [host, realm]}}\fR\& option to \fBdiameter:call/4\fR\&) will be placed at the head of the list\&.
.LP
The return values \fIfalse\fR\& and \fI{false, State}\fR\& are equivalent when callback state is mutable, as are \fI{ok, Peer}\fR\& and \fI{Peer, State}\fR\&\&. Returning a peer as \fIfalse\fR\& causes \fI{error, no_connection}\fR\& to be returned from \fBdiameter:call/4\fR\&\&. Returning a peer() from an initial pick_peer/4 callback will result in a \fBprepare_request/3\fR\& callback followed by either \fBhandle_answer/4\fR\& or \fBhandle_error/4\fR\& depending on whether or not an answer message is received from the peer\&. If transport with the peer is lost before this then a new \fBpick_peer/4\fR\& callback takes place to select an alternate peer\&.
.LP
Note that there is no guarantee that a \fBpick_peer/4\fR\& callback to select an alternate peer will be followed by any additional callbacks, only that the initial \fBpick_peer/4\fR\& will be, since a retransmission to an alternate peer is abandoned if an answer is received from a previously selected peer\&.
.RE
.LP
.B
Mod:prepare_request(Packet, SvcName, Peer) -> Action
.br
.RS
.TP 3
Types:

Packet = packet()
.br
SvcName = service_name()
.br
Peer = peer()
.br
Action = {send, packet() | message()} | {discard, Reason} | discard
.br
.RE
.RS
.LP
Invoked to return a request for encoding and transport\&. Allows the sender to access the selected peer\&'s capabilities in order to set (for example) \fIDestination-Host\fR\& and/or \fIDestination-Realm\fR\& in the outgoing request, although the callback need not be limited to this usage\&. Many implementations may simply want to return \fI{send, Packet}\fR\&
.LP
A returned packet() should set the request to be encoded in its \fImsg\fR\& field and can set the \fItransport_data\fR\& field in order to pass information to the transport module\&. Extra arguments passed to \fBdiameter:call/4\fR\& can be used to communicate transport data to the callback\&. A returned packet() can also set the \fIheader\fR\& field to a \fIdiameter_header\fR\& record in order to specify values that should be preserved in the outgoing request, although this should typically not be necessary and allows the callback to set header values inappropriately\&. A returned \fIlength\fR\&, \fIcmd_code\fR\& or \fIapplication_id\fR\& is ignored\&.
.LP
Returning \fI{discard, Reason}\fR\& causes the request to be aborted and the \fBdiameter:call/4\fR\& for which the callback has taken place to return \fI{error, Reason}\fR\&\&. Returning \fIdiscard\fR\& is equivalent to returning \fI{discard, discarded}\fR\&\&.
.RE
.LP
.B
Mod:prepare_retransmit(Packet, SvcName, Peer) -> Result
.br
.RS
.TP 3
Types:

Packet = packet()
.br
SvcName = service_name()
.br
Peer = peer()
.br
Result = {send, packet() | message()} | {discard, Reason} | discard
.br
.RE
.RS
.LP
Invoked to return a request for encoding and retransmission\&. Has the same role as \fBprepare_request/3\fR\& in the case that a peer connection is lost an an alternate peer selected but the argument packet() is as returned by the initial \fIprepare_request/3\fR\&\&.
.LP
Returning \fI{discard, Reason}\fR\& causes the request to be aborted and a \fBhandle_error/4\fR\& callback to take place with \fIReason\fR\& as initial argument\&. Returning \fIdiscard\fR\& is equivalent to returning \fI{discard, discarded}\fR\&\&.
.RE
.LP
.B
Mod:handle_answer(Packet, Request, SvcName, Peer) -> Result
.br
.RS
.TP 3
Types:

Packet = packet()
.br
Request = message()
.br
SvcName = service_name()
.br
Peer = peer()
.br
Result = term()
.br
.RE
.RS
.LP
Invoked when an answer message is received from a peer\&. The return value is returned from the call to \fBdiameter:call/4\fR\& for which the callback takes place unless the \fIdetach\fR\& option was specified\&.
.LP
The decoded answer record is in the \fImsg\fR\& field of the argument packet(), the undecoded binary in the \fIpacket\fR\& field\&. \fIRequest\fR\& is the outgoing request message as was returned from \fBprepare_request/3\fR\& or \fBprepare_retransmit/3\fR\& before the request was passed to the transport\&.
.LP
For any given call to \fBdiameter:call/4\fR\& there is at most one call to the handle_answer callback of the application in question: any duplicate answer (due to retransmission or otherwise) is discarded\&. Similarly, only one of \fIhandle_answer/4\fR\& or \fIhandle_error/4\fR\& is called for any given request\&.
.LP
By default, an incoming answer message that cannot be successfully decoded causes the request process in question to fail, causing the relevant call to \fBdiameter:call/4\fR\& to return \fI{error, failure} (unless the \fIdetach\fR\& option was specified)\fR\&\&. In particular, there is no \fIhandle_error/4\fR\& callback in this case\&. Application configuration may change this behaviour as described for \fBdiameter:start_service/2\fR\&\&.
.RE
.LP
.B
Mod:handle_error(Reason, Request, SvcName, Peer) -> Result
.br
.RS
.TP 3
Types:

Reason = timeout | failover | term()
.br
Request = message()
.br
SvcName = service_name()
.br
Peer = peer()
.br
Result = term()
.br
.RE
.RS
.LP
Invoked when an error occurs before an answer message is received from a peer in response to an outgoing request\&. The return value is returned from the call to \fBdiameter:call/4\fR\& for which the callback takes place (unless the \fIdetach\fR\& option was specified)\&.
.LP
Reason \fItimeout\fR\& indicates that an answer message has not been received within the required time\&. Reason \fIfailover\fR\& indicates that the transport connection to the peer to which the request has been sent has been lost but that not alternate node was available, possibly because a \fBpick_peer/4\fR\& callback returned false\&.
.RE
.LP
.B
Mod:handle_request(Packet, SvcName, Peer) -> Action
.br
.RS
.TP 3
Types:

Packet = packet()
.br
SvcName = term()
.br
Peer = peer()
.br
Action = Reply | {relay, Opts} | discard | {eval, Action, PostF}
.br
Reply = {reply, message()} | {protocol_error, 3000..3999}
.br
Opts = diameter:call_opts()
.br
PostF = diameter:evaluable()
.br
.RE
.RS
.LP
Invoked when a request message is received from a peer\&. The application in which the callback takes place (that is, the callback module as configured with \fBdiameter:start_service/2\fR\&) is determined by the Application Identifier in the header of the incoming request message, the selected module being the one whose corresponding \fBdictionary\fR\& declares itself as defining either the application in question or the Relay application\&.
.LP
The argument packet() has the following signature\&.
.LP
.nf

#diameter_packet{header = #diameter_header{},
                 avps   = [#diameter_avp{}],
                 msg    = record() | undefined,
                 errors = ['Unsigned32'() | {'Unsigned32'(), #diameter_avp{}}],
                 bin    = binary(),
                 transport_data = term()}

.fi
.LP
The \fImsg\fR\& field will be \fIundefined\fR\& only in case the request has been received in the relay application\&. Otherwise it contains the record representing the request as outlined in \fBdiameter_dict(4)\fR\&\&.
.LP
The \fIerrors\fR\& field specifies any Result-Code\&'s identifying errors that were encountered in decoding the request\&. In this case diameter will set both Result-Code and Failed-AVP AVP\&'s in a returned answer message() before sending it to the peer: the returned message() need only set any other required AVP\&'s\&. Note that the errors detected by diameter are all of the 5xxx series (Permanent Failures)\&. The \fIerrors\fR\& list is empty if the request has been received in the relay application\&.
.LP
The \fItransport_data\fR\& field contains an arbitrary term passed into diameter from the transport module in question, or the atom \fIundefined\fR\& if the transport specified no data\&. The term is preserved in the packet() containing any answer message sent back to the transport process unless another value is explicitly specified\&.
.LP
The semantics of each of the possible return values are as follows\&.
.RS 2
.TP 2
.B
\fI{reply, message()}\fR\&:
Send the specified answer message to the peer\&.
.TP 2
.B
\fI{protocol_error, 3000\&.\&.3999}\fR\&:
Send an answer message to the peer containing the specified protocol error\&. Equivalent to
.LP
.nf

{reply, ['answer-message' | Avps]

.fi
.RS 2
.LP
where \fIAvps\fR\& sets the Origin-Host, Origin-Realm, the specified Result-Code and (if the request sent one) Session-Id AVP\&'s\&.
.RE
.RS 2
.LP
Note that RFC 3588 mandates that only answers with a 3xxx series Result-Code (protocol errors) may set the E bit\&. Returning a non-3xxx value in a \fIprotocol_error\fR\& tuple will cause the request process in question to fail\&.
.RE
.TP 2
.B
\fI{relay, Opts}\fR\&:
Relay a request to another peer in the role of a Diameter relay agent\&. If a routing loop is detected then the request is answered with 3005 (DIAMETER_LOOP_DETECTED)\&. Otherwise a Route-Record AVP (containing the sending peer\&'s Origin-Host) is added to the request and \fBpick_peer/4\fR\& and subsequent callbacks take place just as if \fBdiameter:call/4\fR\& had been called explicitly\&. The End-to-End Identifier of the incoming request is preserved in the header of the relayed request\&.
.RS 2
.LP
The returned \fIOpts\fR\& should not specify \fIdetach\fR\&\&. A subsequent \fBhandle_answer/4\fR\& callback for the relayed request must return its first argument, the \fIdiameter_packet\fR\& record containing the answer message\&. Note that the \fIextra\fR\& option can be specified to supply arguments that can distinguish the relay case from others if so desired\&. Any other return value (for example, from a \fBhandle_error/4\fR\& callback) causes the request to be answered with 3002 (DIAMETER_UNABLE_TO_DELIVER)\&.
.RE
.TP 2
.B
\fIdiscard\fR\&:
Discard the request\&.
.TP 2
.B
\fI{eval, Action, PostF}\fR\&:
Handle the request as if \fIAction\fR\& has been returned and then evaluate \fIPostF\fR\& in the request process\&.
.RE
.LP
Note that protocol errors detected by diameter will result in an answer message without \fIhandle_request/3\fR\& being invoked\&.
.RE