.TH crypto 3 "crypto 2.0.4" "Ericsson AB" "Erlang Module Definition"
.SH NAME
crypto \- Crypto Functions
.SH DESCRIPTION
.LP
This module provides a set of cryptographic functions\&.
.LP
References:
.RS 2
.TP 2
*
md4: The MD4 Message Digest Algorithm (RFC 1320)
.LP
.TP 2
*
md5: The MD5 Message Digest Algorithm (RFC 1321)
.LP
.TP 2
*
sha: Secure Hash Standard (FIPS 180-2)
.LP
.TP 2
*
hmac: Keyed-Hashing for Message Authentication (RFC 2104)
.LP
.TP 2
*
des: Data Encryption Standard (FIPS 46-3)
.LP
.TP 2
*
aes: Advanced Encryption Standard (AES) (FIPS 197)
.LP
.TP 2
*
ecb, cbc, cfb, ofb, ctr: Recommendation for Block Cipher Modes of Operation (NIST SP 800-38A)\&.
.LP
.TP 2
*
rsa: Recommendation for Block Cipher Modes of Operation (NIST 800-38A)
.LP
.TP 2
*
dss: Digital Signature Standard (FIPS 186-2)
.LP
.RE

.LP
The above publications can be found at NIST publications, at IETF\&.
.LP
\fITypes\fR\&
.LP
.nf

byte() = 0 ... 255
ioelem() = byte() | binary() | iolist()
iolist() = [ioelem()]
Mpint() = <<ByteLen:32/integer-big, Bytes:ByteLen/binary>>
    
.fi
.LP

.SH EXPORTS
.LP
.B
start() -> ok
.br
.RS
.LP
Starts the crypto server\&.
.RE
.LP
.B
stop() -> ok
.br
.RS
.LP
Stops the crypto server\&.
.RE
.LP
.B
info() -> [atom()]
.br
.RS
.LP
Provides the available crypto functions in terms of a list of atoms\&.
.RE
.LP
.B
info_lib() -> [{Name,VerNum,VerStr}]
.br
.RS
.TP 3
Types:

Name = binary()
.br
VerNum = integer()
.br
VerStr = binary()
.br
.RE
.RS
.LP
Provides the name and version of the libraries used by crypto\&.
.LP
\fIName\fR\& is the name of the library\&. \fIVerNum\fR\& is the numeric version according to the library\&'s own versioning scheme\&. \fIVerStr\fR\& contains a text variant of the version\&.
.LP
.nf

> info_lib()\&.
[{<<"OpenSSL">>,9469983,<<"OpenSSL 0.9.8a 11 Oct 2005">>}]
        
.fi
.RE
.LP
.B
md4(Data) -> Digest
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
Digest = binary()
.br
.RE
.RS
.LP
Computes an \fIMD4\fR\& message digest from \fIData\fR\&, where the length of the digest is 128 bits (16 bytes)\&.
.RE
.LP
.B
md4_init() -> Context
.br
.RS
.TP 3
Types:

Context = binary()
.br
.RE
.RS
.LP
Creates an MD4 context, to be used in subsequent calls to \fImd4_update/2\fR\&\&.
.RE
.LP
.B
md4_update(Context, Data) -> NewContext
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
Context = NewContext = binary()
.br
.RE
.RS
.LP
Updates an MD4 \fIContext\fR\& with \fIData\fR\&, and returns a \fINewContext\fR\&\&.
.RE
.LP
.B
md4_final(Context) -> Digest
.br
.RS
.TP 3
Types:

Context = Digest = binary()
.br
.RE
.RS
.LP
Finishes the update of an MD4 \fIContext\fR\& and returns the computed \fIMD4\fR\& message digest\&.
.RE
.LP
.B
md5(Data) -> Digest
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
Digest = binary()
.br
.RE
.RS
.LP
Computes an \fIMD5\fR\& message digest from \fIData\fR\&, where the length of the digest is 128 bits (16 bytes)\&.
.RE
.LP
.B
md5_init() -> Context
.br
.RS
.TP 3
Types:

Context = binary()
.br
.RE
.RS
.LP
Creates an MD5 context, to be used in subsequent calls to \fImd5_update/2\fR\&\&.
.RE
.LP
.B
md5_update(Context, Data) -> NewContext
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
Context = NewContext = binary()
.br
.RE
.RS
.LP
Updates an MD5 \fIContext\fR\& with \fIData\fR\&, and returns a \fINewContext\fR\&\&.
.RE
.LP
.B
md5_final(Context) -> Digest
.br
.RS
.TP 3
Types:

Context = Digest = binary()
.br
.RE
.RS
.LP
Finishes the update of an MD5 \fIContext\fR\& and returns the computed \fIMD5\fR\& message digest\&.
.RE
.LP
.B
sha(Data) -> Digest
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
Digest = binary()
.br
.RE
.RS
.LP
Computes an \fISHA\fR\& message digest from \fIData\fR\&, where the length of the digest is 160 bits (20 bytes)\&.
.RE
.LP
.B
sha_init() -> Context
.br
.RS
.TP 3
Types:

Context = binary()
.br
.RE
.RS
.LP
Creates an SHA context, to be used in subsequent calls to \fIsha_update/2\fR\&\&.
.RE
.LP
.B
sha_update(Context, Data) -> NewContext
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
Context = NewContext = binary()
.br
.RE
.RS
.LP
Updates an SHA \fIContext\fR\& with \fIData\fR\&, and returns a \fINewContext\fR\&\&.
.RE
.LP
.B
sha_final(Context) -> Digest
.br
.RS
.TP 3
Types:

Context = Digest = binary()
.br
.RE
.RS
.LP
Finishes the update of an SHA \fIContext\fR\& and returns the computed \fISHA\fR\& message digest\&.
.RE
.LP
.B
md5_mac(Key, Data) -> Mac
.br
.RS
.TP 3
Types:

Key = Data = iolist() | binary()
.br
Mac = binary()
.br
.RE
.RS
.LP
Computes an \fIMD5 MAC\fR\& message authentification code from \fIKey\fR\& and \fIData\fR\&, where the the length of the Mac is 128 bits (16 bytes)\&.
.RE
.LP
.B
md5_mac_96(Key, Data) -> Mac
.br
.RS
.TP 3
Types:

Key = Data = iolist() | binary()
.br
Mac = binary()
.br
.RE
.RS
.LP
Computes an \fIMD5 MAC\fR\& message authentification code from \fIKey\fR\& and \fIData\fR\&, where the length of the Mac is 96 bits (12 bytes)\&.
.RE
.LP
.B
hmac_init(Type, Key) -> Context
.br
.RS
.TP 3
Types:

Type = sha | md5 | ripemd160
.br
Key = iolist() | binary()
.br
Context = binary()
.br
.RE
.RS
.LP
Initializes the context for streaming HMAC operations\&. \fIType\fR\& determines which hash function to use in the HMAC operation\&. \fIKey\fR\& is the authentication key\&. The key can be any length\&.
.RE
.LP
.B
hmac_update(Context, Data) -> NewContext
.br
.RS
.TP 3
Types:

Context = NewContext = binary()
.br
Data = iolist() | binary()
.br
.RE
.RS
.LP
Updates the HMAC represented by \fIContext\fR\& using the given \fIData\fR\&\&. \fIContext\fR\& must have been generated using an HMAC init function (such as \fBhmac_init\fR\&)\&. \fIData\fR\& can be any length\&. \fINewContext\fR\& must be passed into the next call to \fIhmac_update\fR\&\&.
.RE
.LP
.B
hmac_final(Context) -> Mac
.br
.RS
.TP 3
Types:

Context = Mac = binary()
.br
.RE
.RS
.LP
Finalizes the HMAC operation referenced by \fIContext\fR\&\&. The size of the resultant MAC is determined by the type of hash function used to generate it\&.
.RE
.LP
.B
hmac_final_n(Context, HashLen) -> Mac
.br
.RS
.TP 3
Types:

Context = Mac = binary()
.br
HashLen = non_neg_integer()
.br
.RE
.RS
.LP
Finalizes the HMAC operation referenced by \fIContext\fR\&\&. \fIHashLen\fR\& must be greater than zero\&. \fIMac\fR\& will be a binary with at most \fIHashLen\fR\& bytes\&. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than \fIHashLen\fR\& bytes\&.
.RE
.LP
.B
sha_mac(Key, Data) -> Mac
.br
.RS
.TP 3
Types:

Key = Data = iolist() | binary()
.br
Mac = binary()
.br
.RE
.RS
.LP
Computes an \fISHA MAC\fR\& message authentification code from \fIKey\fR\& and \fIData\fR\&, where the length of the Mac is 160 bits (20 bytes)\&.
.RE
.LP
.B
sha_mac_96(Key, Data) -> Mac
.br
.RS
.TP 3
Types:

Key = Data = iolist() | binary()
.br
Mac = binary()
.br
.RE
.RS
.LP
Computes an \fISHA MAC\fR\& message authentification code from \fIKey\fR\& and \fIData\fR\&, where the length of the Mac is 96 bits (12 bytes)\&.
.RE
.LP
.B
des_cbc_encrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& according to DES in CBC mode\&. \fIText\fR\& must be a multiple of 64 bits (8 bytes)\&. \fIKey\fR\& is the DES key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The lengths of \fIKey\fR\& and \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
des_cbc_decrypt(Key, IVec, Cipher) -> Text
.br
.RS
.TP 3
Types:

Key = Cipher = iolist() | binary()
.br
IVec = Text = binary()
.br
.RE
.RS
.LP
Decrypts \fICipher\fR\& according to DES in CBC mode\&. \fIKey\fR\& is the DES key, and \fIIVec\fR\& is an arbitrary initializing vector\&. \fIKey\fR\& and \fIIVec\fR\& must have the same values as those used when encrypting\&. \fICipher\fR\& must be a multiple of 64 bits (8 bytes)\&. The lengths of \fIKey\fR\& and \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
des_cbc_ivec(Data) -> IVec
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
IVec = binary()
.br
.RE
.RS
.LP
Returns the \fIIVec\fR\& to be used in a next iteration of \fIdes_cbc_[encrypt|decrypt]\fR\&\&. \fIData\fR\& is the encrypted data from the previous iteration step\&.
.RE
.LP
.B
des3_cbc_encrypt(Key1, Key2, Key3, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key1 =Key2 = Key3 Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& according to DES3 in CBC mode\&. \fIText\fR\& must be a multiple of 64 bits (8 bytes)\&. \fIKey1\fR\&, \fIKey2\fR\&, \fIKey3\fR\&, are the DES keys, and \fIIVec\fR\& is an arbitrary initializing vector\&. The lengths of each of \fIKey1\fR\&, \fIKey2\fR\&, \fIKey3\fR\& and \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
des3_cbc_decrypt(Key1, Key2, Key3, IVec, Cipher) -> Text
.br
.RS
.TP 3
Types:

Key1 = Key2 = Key3 = Cipher = iolist() | binary()
.br
IVec = Text = binary()
.br
.RE
.RS
.LP
Decrypts \fICipher\fR\& according to DES3 in CBC mode\&. \fIKey1\fR\&, \fIKey2\fR\&, \fIKey3\fR\& are the DES key, and \fIIVec\fR\& is an arbitrary initializing vector\&. \fIKey1\fR\&, \fIKey2\fR\&, \fIKey3\fR\& and \fIIVec\fR\& must and \fIIVec\fR\& must have the same values as those used when encrypting\&. \fICipher\fR\& must be a multiple of 64 bits (8 bytes)\&. The lengths of \fIKey1\fR\&, \fIKey2\fR\&, \fIKey3\fR\&, and \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
des_ecb_encrypt(Key, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& according to DES in ECB mode\&. \fIKey\fR\& is the DES key\&. The lengths of \fIKey\fR\& and \fIText\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
des_ecb_decrypt(Key, Cipher) -> Text
.br
.RS
.TP 3
Types:

Key = Cipher = iolist() | binary()
.br
Text = binary()
.br
.RE
.RS
.LP
Decrypts \fICipher\fR\& according to DES in ECB mode\&. \fIKey\fR\& is the DES key\&. The lengths of \fIKey\fR\& and \fICipher\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_ecb_encrypt(Key, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
Cipher = binary()
.br
.RE
.RS
.LP
Encrypts the first 64 bits of \fIText\fR\& using Blowfish in ECB mode\&. \fIKey\fR\& is the Blowfish key\&. The length of \fIText\fR\& must be at least 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_ecb_decrypt(Key, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
Cipher = binary()
.br
.RE
.RS
.LP
Decrypts the first 64 bits of \fIText\fR\& using Blowfish in ECB mode\&. \fIKey\fR\& is the Blowfish key\&. The length of \fIText\fR\& must be at least 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_cbc_encrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& using Blowfish in CBC mode\&. \fIKey\fR\& is the Blowfish key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The length of \fIIVec\fR\& must be 64 bits (8 bytes)\&. The length of \fIText\fR\& must be a multiple of 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_cbc_decrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Decrypts \fIText\fR\& using Blowfish in CBC mode\&. \fIKey\fR\& is the Blowfish key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The length of \fIIVec\fR\& must be 64 bits (8 bytes)\&. The length of \fIText\fR\& must be a multiple 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_cfb64_encrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& using Blowfish in CFB mode with 64 bit feedback\&. \fIKey\fR\& is the Blowfish key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The length of \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_cfb64_decrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Decrypts \fIText\fR\& using Blowfish in CFB mode with 64 bit feedback\&. \fIKey\fR\& is the Blowfish key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The length of \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
blowfish_ofb64_encrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& using Blowfish in OFB mode with 64 bit feedback\&. \fIKey\fR\& is the Blowfish key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The length of \fIIVec\fR\& must be 64 bits (8 bytes)\&.
.RE
.LP
.B
aes_cfb_128_encrypt(Key, IVec, Text) -> Cipher
.br
.B
aes_cbc_128_encrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& according to AES in Cipher Feedback mode (CFB) or Cipher Block Chaining mode (CBC)\&. \fIText\fR\& must be a multiple of 128 bits (16 bytes)\&. \fIKey\fR\& is the AES key, and \fIIVec\fR\& is an arbitrary initializing vector\&. The lengths of \fIKey\fR\& and \fIIVec\fR\& must be 128 bits (16 bytes)\&.
.RE
.LP
.B
aes_cfb_128_decrypt(Key, IVec, Cipher) -> Text
.br
.B
aes_cbc_128_decrypt(Key, IVec, Cipher) -> Text
.br
.RS
.TP 3
Types:

Key = Cipher = iolist() | binary()
.br
IVec = Text = binary()
.br
.RE
.RS
.LP
Decrypts \fICipher\fR\& according to Cipher Feedback Mode (CFB) or Cipher Block Chaining mode (CBC)\&. \fIKey\fR\& is the AES key, and \fIIVec\fR\& is an arbitrary initializing vector\&. \fIKey\fR\& and \fIIVec\fR\& must have the same values as those used when encrypting\&. \fICipher\fR\& must be a multiple of 128 bits (16 bytes)\&. The lengths of \fIKey\fR\& and \fIIVec\fR\& must be 128 bits (16 bytes)\&.
.RE
.LP
.B
aes_cbc_ivec(Data) -> IVec
.br
.RS
.TP 3
Types:

Data = iolist() | binary()
.br
IVec = binary()
.br
.RE
.RS
.LP
Returns the \fIIVec\fR\& to be used in a next iteration of \fIaes_cbc_*_[encrypt|decrypt]\fR\&\&. \fIData\fR\& is the encrypted data from the previous iteration step\&.
.RE
.LP
.B
aes_ctr_encrypt(Key, IVec, Text) -> Cipher
.br
.RS
.TP 3
Types:

Key = Text = iolist() | binary()
.br
IVec = Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& according to AES in Counter mode (CTR)\&. \fIText\fR\& can be any number of bytes\&. \fIKey\fR\& is the AES key and must be either 128, 192 or 256 bits long\&. \fIIVec\fR\& is an arbitrary initializing vector of 128 bits (16 bytes)\&.
.RE
.LP
.B
aes_ctr_decrypt(Key, IVec, Cipher) -> Text
.br
.RS
.TP 3
Types:

Key = Cipher = iolist() | binary()
.br
IVec = Text = binary()
.br
.RE
.RS
.LP
Decrypts \fICipher\fR\& according to AES in Counter mode (CTR)\&. \fICipher\fR\& can be any number of bytes\&. \fIKey\fR\& is the AES key and must be either 128, 192 or 256 bits long\&. \fIIVec\fR\& is an arbitrary initializing vector of 128 bits (16 bytes)\&.
.RE
.LP
.B
aes_ctr_stream_init(Key, IVec) -> State
.br
.RS
.TP 3
Types:

State = { K, I, E, C }
.br
Key = K = iolist()
.br
IVec = I = E = binary()
.br
C = integer()
.br
.RE
.RS
.LP
Initializes the state for use in streaming AES encryption using Counter mode (CTR)\&. \fIKey\fR\& is the AES key and must be either 128, 192, or 256 bts long\&. \fIIVec\fR\& is an arbitrary initializing vector of 128 bits (16 bytes)\&. This state is for use with \fBaes_ctr_stream_encrypt\fR\& and \fBaes_ctr_stream_decrypt\fR\&\&.
.RE
.LP
.B
aes_ctr_stream_encrypt(State, Text) -> { NewState, Cipher}
.br
.RS
.TP 3
Types:

Text = iolist() | binary()
.br
Cipher = binary()
.br
.RE
.RS
.LP
Encrypts \fIText\fR\& according to AES in Counter mode (CTR)\&. This function can be used to encrypt a stream of text using a series of calls instead of requiring all text to be in memory\&. \fIText\fR\& can be any number of bytes\&. State is initialized using \fBaes_ctr_stream_init\fR\&\&. \fINewState\fR\& is the new streaming encryption state that must be passed to the next call to \fIaes_ctr_stream_encrypt\fR\&\&. \fICipher\fR\& is the encrypted cipher text\&.
.RE
.LP
.B
aes_ctr_stream_decrypt(State, Cipher) -> { NewState, Text }
.br
.RS
.TP 3
Types:

Cipher = iolist() | binary()
.br
Text = binary()
.br
.RE
.RS
.LP
Decrypts \fICipher\fR\& according to AES in Counter mode (CTR)\&. This function can be used to decrypt a stream of ciphertext using a series of calls instead of requiring all ciphertext to be in memory\&. \fICipher\fR\& can be any number of bytes\&. State is initialized using \fBaes_ctr_stream_init\fR\&\&. \fINewState\fR\& is the new streaming encryption state that must be passed to the next call to \fIaes_ctr_stream_encrypt\fR\&\&. \fIText\fR\& is the decrypted data\&.
.RE
.LP
.B
erlint(Mpint) -> N
.br
.B
mpint(N) -> Mpint
.br
.RS
.TP 3
Types:

Mpint = binary()
.br
N = integer()
.br
.RE
.RS
.LP
Convert a binary multi-precision integer \fIMpint\fR\& to and from an erlang big integer\&. A multi-precision integer is a binary with the following form: \fI<<ByteLen:32/integer, Bytes:ByteLen/binary>>\fR\& where both \fIByteLen\fR\& and \fIBytes\fR\& are big-endian\&. Mpints are used in some of the functions in \fIcrypto\fR\& and are not translated in the API for performance reasons\&.
.RE
.LP
.B
rand_bytes(N) -> binary()
.br
.RS
.TP 3
Types:

N = integer()
.br
.RE
.RS
.LP
Generates N bytes randomly uniform 0\&.\&.255, and returns the result in a binary\&. Uses the \fIcrypto\fR\& library pseudo-random number generator\&.
.RE
.LP
.B
strong_rand_bytes(N) -> binary()
.br
.RS
.TP 3
Types:

N = integer()
.br
.RE
.RS
.LP
Generates N bytes randomly uniform 0\&.\&.255, and returns the result in a binary\&. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy\&. By default this is the \fIRAND_bytes\fR\& method from OpenSSL\&.
.LP
May throw exception \fIlow_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.RE
.LP
.B
rand_uniform(Lo, Hi) -> N
.br
.RS
.TP 3
Types:

Lo, Hi, N = Mpint | integer()
.br
Mpint = binary()
.br
.RE
.RS
.LP
Generate a random number \fIN, Lo =< N < Hi\&.\fR\& Uses the \fIcrypto\fR\& library pseudo-random number generator\&. The arguments (and result) can be either erlang integers or binary multi-precision integers\&. \fIHi\fR\& must be larger than \fILo\fR\&\&.
.RE
.LP
.B
strong_rand_mpint(N, Top, Bottom) -> Mpint
.br
.RS
.TP 3
Types:

N = non_neg_integer()
.br
Top = -1 | 0 | 1
.br
Bottom = 0 | 1
.br
Mpint = binary()
.br
.RE
.RS
.LP
Generate an N bit random number using OpenSSL\&'s cryptographically strong pseudo random number generator \fIBN_rand\fR\&\&.
.LP
The parameter \fITop\fR\& places constraints on the most significant bits of the generated number\&. If \fITop\fR\& is 1, then the two most significant bits will be set to 1, if \fITop\fR\& is 0, the most significant bit will be 1, and if \fITop\fR\& is -1 then no constraints are applied and thus the generated number may be less than N bits long\&.
.LP
If \fIBottom\fR\& is 1, then the generated number is constrained to be odd\&.
.LP
May throw exception \fIlow_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.RE
.LP
.B
mod_exp(N, P, M) -> Result
.br
.RS
.TP 3
Types:

N, P, M, Result = Mpint
.br
Mpint = binary()
.br
.RE
.RS
.LP
This function performs the exponentiation \fIN ^ P mod M\fR\&, using the \fIcrypto\fR\& library\&.
.RE
.LP
.B
rsa_sign(Data, Key) -> Signature
.br
.B
rsa_sign(DigestType, Data, Key) -> Signature
.br
.RS
.TP 3
Types:

Data = Mpint
.br
Key = [E, N, D]
.br
E, N, D = Mpint
.br
Where \fIE\fR\& is the public exponent, \fIN\fR\& is public modulus and \fID\fR\& is the private exponent\&.
.br
DigestType = md5 | sha
.br
The default \fIDigestType\fR\& is sha\&.
.br
Mpint = binary()
.br
Signature = binary()
.br
.RE
.RS
.LP
Calculates a \fIDigestType\fR\& digest of the \fIData\fR\& and creates a RSA signature with the private key \fIKey\fR\& of the digest\&.
.RE
.LP
.B
rsa_verify(Data, Signature, Key) -> Verified
.br
.B
rsa_verify(DigestType, Data, Signature, Key) -> Verified 
.br
.RS
.TP 3
Types:

Verified = boolean()
.br
Data, Signature = Mpint
.br
Key = [E, N]
.br
E, N = Mpint
.br
Where \fIE\fR\& is the public exponent and \fIN\fR\& is public modulus\&.
.br
DigestType = md5 | sha
.br
 The default \fIDigestType\fR\& is sha\&.
.br
Mpint = binary()
.br
.RE
.RS
.LP
Calculates a \fIDigestType\fR\& digest of the \fIData\fR\& and verifies that the digest matches the RSA signature using the signer\&'s public key \fIKey\fR\&\&.
.RE
.LP
.B
rsa_public_encrypt(PlainText, PublicKey, Padding) -> ChipherText
.br
.RS
.TP 3
Types:

PlainText = binary()
.br
PublicKey = [E, N]
.br
E, N = Mpint
.br
Where \fIE\fR\& is the public exponent and \fIN\fR\& is public modulus\&.
.br
Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding
.br
ChipherText = binary()
.br
.RE
.RS
.LP
Encrypts the \fIPlainText\fR\& (usually a session key) using the \fIPublicKey\fR\& and returns the cipher\&. The \fIPadding\fR\& decides what padding mode is used, \fIrsa_pkcs1_padding\fR\& is PKCS #1 v1\&.5 currently the most used mode and \fIrsa_pkcs1_oaep_padding\fR\& is EME-OAEP as defined in PKCS #1 v2\&.0 with SHA-1, MGF1 and an empty encoding parameter\&. This mode is recommended for all new applications\&. The size of the \fIMsg\fR\& must be less than \fIbyte_size(N)-11\fR\& if \fIrsa_pkcs1_padding\fR\& is used, \fIbyte_size(N)-41\fR\& if \fIrsa_pkcs1_oaep_padding\fR\& is used and \fIbyte_size(N)\fR\& if \fIrsa_no_padding\fR\& is used\&. Where byte_size(N) is the size part of an \fIMpint-1\fR\&\&.
.RE
.LP
.B
rsa_private_decrypt(ChipherText, PrivateKey, Padding) -> PlainText
.br
.RS
.TP 3
Types:

ChipherText = binary()
.br
PrivateKey = [E, N, D]
.br
E, N, D = Mpint
.br
Where \fIE\fR\& is the public exponent, \fIN\fR\& is public modulus and \fID\fR\& is the private exponent\&.
.br
Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding
.br
PlainText = binary()
.br
.RE
.RS
.LP
Decrypts the \fIChipherText\fR\& (usually a session key encrypted with \fBrsa_public_encrypt/3\fR\&) using the \fIPrivateKey\fR\& and returns the message\&. The \fIPadding\fR\& is the padding mode that was used to encrypt the data, see \fBrsa_public_encrypt/3\fR\&\&.
.RE
.LP
.B
rsa_private_encrypt(PlainText, PrivateKey, Padding) -> ChipherText
.br
.RS
.TP 3
Types:

PlainText = binary()
.br
PrivateKey = [E, N, D]
.br
E, N, D = Mpint
.br
Where \fIE\fR\& is the public exponent, \fIN\fR\& is public modulus and \fID\fR\& is the private exponent\&.
.br
Padding = rsa_pkcs1_padding | rsa_no_padding
.br
ChipherText = binary()
.br
.RE
.RS
.LP
Encrypts the \fIPlainText\fR\& using the \fIPrivateKey\fR\& and returns the cipher\&. The \fIPadding\fR\& decides what padding mode is used, \fIrsa_pkcs1_padding\fR\& is PKCS #1 v1\&.5 currently the most used mode\&. The size of the \fIMsg\fR\& must be less than \fIbyte_size(N)-11\fR\& if \fIrsa_pkcs1_padding\fR\& is used, and \fIbyte_size(N)\fR\& if \fIrsa_no_padding\fR\& is used\&. Where byte_size(N) is the size part of an \fIMpint-1\fR\&\&.
.RE
.LP
.B
rsa_public_decrypt(ChipherText, PublicKey, Padding) -> PlainText
.br
.RS
.TP 3
Types:

ChipherText = binary()
.br
PublicKey = [E, N]
.br
E, N = Mpint
.br
Where \fIE\fR\& is the public exponent and \fIN\fR\& is public modulus
.br
Padding = rsa_pkcs1_padding | rsa_no_padding
.br
PlainText = binary()
.br
.RE
.RS
.LP
Decrypts the \fIChipherText\fR\& (encrypted with \fBrsa_private_encrypt/3\fR\&) using the \fIPrivateKey\fR\& and returns the message\&. The \fIPadding\fR\& is the padding mode that was used to encrypt the data, see \fBrsa_private_encrypt/3\fR\&\&.
.RE
.LP
.B
dss_sign(Data, Key) -> Signature
.br
.B
dss_sign(DigestType, Data, Key) -> Signature
.br
.RS
.TP 3
Types:

DigestType = sha | none (default is sha)
.br
Data = Mpint | ShaDigest
.br
Key = [P, Q, G, X]
.br
P, Q, G, X = Mpint
.br
 Where \fIP\fR\&, \fIQ\fR\& and \fIG\fR\& are the dss parameters and \fIX\fR\& is the private key\&.
.br
ShaDigest = binary() with length 20 bytes
.br
Signature = binary()
.br
.RE
.RS
.LP
Creates a DSS signature with the private key \fIKey\fR\& of a digest\&. If \fIDigestType\fR\& is \&'sha\&', the digest is calculated as SHA1 of \fIData\fR\&\&. If \fIDigestType\fR\& is \&'none\&', \fIData\fR\& is the precalculated SHA1 digest\&.
.RE
.LP
.B
dss_verify(Data, Signature, Key) -> Verified
.br
.B
dss_verify(DigestType, Data, Signature, Key) -> Verified
.br
.RS
.TP 3
Types:

Verified = boolean()
.br
DigestType = sha | none
.br
Data = Mpint | ShaDigest
.br
Signature = Mpint
.br
Key = [P, Q, G, Y]
.br
P, Q, G, Y = Mpint
.br
 Where \fIP\fR\&, \fIQ\fR\& and \fIG\fR\& are the dss parameters and \fIY\fR\& is the public key\&.
.br
ShaDigest = binary() with length 20 bytes
.br
.RE
.RS
.LP
Verifies that a digest matches the DSS signature using the public key \fIKey\fR\&\&. If \fIDigestType\fR\& is \&'sha\&', the digest is calculated as SHA1 of \fIData\fR\&\&. If \fIDigestType\fR\& is \&'none\&', \fIData\fR\& is the precalculated SHA1 digest\&.
.RE
.LP
.B
rc4_encrypt(Key, Data) -> Result
.br
.RS
.TP 3
Types:

Key, Data = iolist() | binary()
.br
Result = binary()
.br
.RE
.RS
.LP
Encrypts the data with RC4 symmetric stream encryption\&. Since it is symmetric, the same function is used for decryption\&.
.RE
.LP
.B
dh_generate_key(DHParams) -> {PublicKey,PrivateKey} 
.br
.B
dh_generate_key(PrivateKey, DHParams) -> {PublicKey,PrivateKey} 
.br
.RS
.TP 3
Types:

DHParameters = [P, G]
.br
P, G = Mpint
.br
 Where \fIP\fR\& is the shared prime number and \fIG\fR\& is the shared generator\&.
.br
PublicKey, PrivateKey = Mpint()
.br
.RE
.RS
.LP
Generates a Diffie-Hellman \fIPublicKey\fR\& and \fIPrivateKey\fR\& (if not given)\&.
.RE
.LP
.B
dh_compute_key(OthersPublicKey, MyPrivateKey, DHParams) -> SharedSecret
.br
.RS
.TP 3
Types:

DHParameters = [P, G]
.br
P, G = Mpint
.br
 Where \fIP\fR\& is the shared prime number and \fIG\fR\& is the shared generator\&.
.br
OthersPublicKey, MyPrivateKey = Mpint()
.br
SharedSecret = binary()
.br
.RE
.RS
.LP
Computes the shared secret from the private key and the other party\&'s public key\&.
.RE
.LP
.B
exor(Data1, Data2) -> Result
.br
.RS
.TP 3
Types:

Data1, Data2 = iolist() | binary()
.br
Result = binary()
.br
.RE
.RS
.LP
Performs bit-wise XOR (exclusive or) on the data supplied\&.
.RE
.SH "DES IN CBC MODE"

.LP
The Data Encryption Standard (DES) defines an algorithm for encrypting and decrypting an 8 byte quantity using an 8 byte key (actually only 56 bits of the key is used)\&.
.LP
When it comes to encrypting and decrypting blocks that are multiples of 8 bytes various modes are defined (NIST SP 800-38A)\&. One of those modes is the Cipher Block Chaining (CBC) mode, where the encryption of an 8 byte segment depend not only of the contents of the segment itself, but also on the result of encrypting the previous segment: the encryption of the previous segment becomes the initializing vector of the encryption of the current segment\&.
.LP
Thus the encryption of every segment depends on the encryption key (which is secret) and the encryption of the previous segment, except the first segment which has to be provided with an initial initializing vector\&. That vector could be chosen at random, or be a counter of some kind\&. It does not have to be secret\&.
.LP
The following example is drawn from the old FIPS 81 standard (replaced by NIST SP 800-38A), where both the plain text and the resulting cipher text is settled\&. The following code fragment returns `true\&'\&.
.LP
.nf


      Key = <<16#01,16#23,16#45,16#67,16#89,16#ab,16#cd,16#ef>>,
      IVec = <<16#12,16#34,16#56,16#78,16#90,16#ab,16#cd,16#ef>>,
      P = "Now is the time for all ",
      C = crypto:des_cbc_encrypt(Key, IVec, P),
         % Which is the same as 
      P1 = "Now is t", P2 = "he time ", P3 = "for all ",
      C1 = crypto:des_cbc_encrypt(Key, IVec, P1),
      C2 = crypto:des_cbc_encrypt(Key, C1, P2),
      C3 = crypto:des_cbc_encrypt(Key, C2, P3),

      C = <<C1/binary, C2/binary, C3/binary>>,
      C = <<16#e5,16#c7,16#cd,16#de,16#87,16#2b,16#f2,16#7c,
             16#43,16#e9,16#34,16#00,16#8c,16#38,16#9c,16#0f,
             16#68,16#37,16#88,16#49,16#9a,16#7c,16#05,16#f6>>,
      <<"Now is the time for all ">> == 
                        crypto:des_cbc_decrypt(Key, IVec, C).
    
.fi
.LP
The following is true for the DES CBC mode\&. For all decompositions \fIP1 ++ P2 = P\fR\& of a plain text message \fIP\fR\& (where the length of all quantities are multiples of 8 bytes), the encryption \fIC\fR\& of \fIP\fR\& is equal to \fIC1 ++ C2\fR\&, where \fIC1\fR\& is obtained by encrypting \fIP1\fR\& with \fIKey\fR\& and the initializing vector \fIIVec\fR\&, and where \fIC2\fR\& is obtained by encrypting \fIP2\fR\& with \fIKey\fR\& and the initializing vector \fIlast8(C1)\fR\&, where \fIlast(Binary)\fR\& denotes the last 8 bytes of the binary \fIBinary\fR\&\&.
.LP
Similarly, for all decompositions \fIC1 ++ C2 = C\fR\& of a cipher text message \fIC\fR\& (where the length of all quantities are multiples of 8 bytes), the decryption \fIP\fR\& of \fIC\fR\& is equal to \fIP1 ++ P2\fR\&, where \fIP1\fR\& is obtained by decrypting \fIC1\fR\& with \fIKey\fR\& and the initializing vector \fIIVec\fR\&, and where \fIP2\fR\& is obtained by decrypting \fIC2\fR\& with \fIKey\fR\& and the initializing vector \fIlast8(C1)\fR\&, where \fIlast8(Binary)\fR\& is as above\&.
.LP
For DES3 (which uses three 64 bit keys) the situation is the same\&.